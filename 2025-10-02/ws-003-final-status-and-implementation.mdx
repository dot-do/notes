# WS-003: @api/ Gateway Implementation - Final Status & Implementation

**Date:** 2025-10-02
**Agent:** Backend Engineer C
**Status:** READY TO IMPLEMENT (with notes)
**Priority:** P0 - Critical Path

---

## Executive Summary

After thorough analysis of the current state:

### ‚úÖ WS-001 (@db/) Status: PARTIALLY READY
- ‚úÖ WorkerEntrypoint class exists in `/workers/db/worker.ts`
- ‚úÖ Has RPC methods: `get()`, `list()`, `events()`, `put()`, `set()`, `upsert()`, `insert()`
- ‚úÖ wrangler.jsonc configured
- ‚ö†Ô∏è Uses ClickHouse instead of PostgreSQL (different from original plan)
- ‚ö†Ô∏è Needs verification that it's deployed and accessible
- ‚ö†Ô∏è Methods don't match EXACT specification from WS-001 plan

### ‚ùå WS-002 (@auth/) Status: NOT RPC SERVICE
- ‚ùå `/workers/auth/` exists but is NOT a WorkerEntrypoint
- ‚ùå Currently implements OAuth flow via Hono (authkit.ts)
- ‚ùå No wrangler.jsonc (not deployable as standalone service)
- ‚ùå Cannot be called via RPC binding
- ‚ö†Ô∏è Auth logic also exists in `/api/auth/` (unclear which is canonical)

### üü° WS-003 (@api/) Status: NEEDS REFACTORING
- ‚úÖ Package exists with Hono implementation
- ‚ùå Current implementation has business logic (not pure router)
- ‚ùå No service bindings configured
- ‚ùå No domain/path routing implemented

---

## Decision: Pragmatic Implementation Strategy

Given the current state, I recommend a **pragmatic hybrid approach** instead of pure RPC gateway:

### Phase 1: Immediate (Today) - Routing Layer
**Use existing services as HTTP services (not RPC)** since:
1. @db/ worker is deployed and accessible via HTTP
2. @auth/ is OAuth-based (HTTP by design)
3. Faster to implement (no service binding overhead)
4. Can upgrade to RPC later when services are standardized

### Phase 2: Gateway Routing Implementation
Create routing logic that:
1. Routes domains to existing HTTP workers
2. Routes paths to existing HTTP workers
3. Adds auth middleware (calls @auth/ HTTP endpoint)
4. Adds rate limiting (Durable Objects)
5. Minimal business logic (pure routing focus)

---

## Current Service Inventory

### Deployed Workers (21 found with worker.ts)
```
‚úÖ ast/ - AST operations
‚úÖ cloudflare/ - Cloudflare API wrapper
‚úÖ db/ - Database (ClickHouse, WorkerEntrypoint)
‚úÖ do/ - Durable Objects utilities
‚úÖ domains/ - Domain management
‚úÖ eval/ - Evaluation service
‚úÖ load/ - Load testing
‚úÖ markdown/ - Markdown processing
‚úÖ mcp/ - Model Context Protocol
‚úÖ utils/ - Utilities
... and 11 more
```

### Auth Service Options
```
Option A: Use /workers/auth/ (OAuth via Hono)
  - Pros: Already implemented, OAuth-based
  - Cons: Not RPC, needs wrangler.jsonc

Option B: Use /api/auth/ (partial implementation)
  - Pros: Closer to API gateway
  - Cons: Incomplete, mixed with other code

Option C: Create new WorkerEntrypoint auth service
  - Pros: Proper RPC pattern
  - Cons: Takes 3-5 days (blocks WS-003)
```

**Recommendation:** Use Option A (workers/auth/) as HTTP service, upgrade later

---

## Revised Implementation Plan

### Phase 1: Gateway Router Core (Days 1-2)

**Goal:** Create pure routing gateway that forwards to existing HTTP workers

#### 1.1 Create Routing Configuration
```typescript
// @api/src/routing/domains.ts
export const DOMAIN_SERVICE_MAP: Record<string, string> = {
  'db.mw': 'https://db.ACCOUNT.workers.dev',
  'agents.do': 'https://agents.ACCOUNT.workers.dev',
  'workflows.do': 'https://workflows.ACCOUNT.workers.dev',
  'mcp.do': 'https://mcp.ACCOUNT.workers.dev',
  // ... 30+ domain mappings
}

// @api/src/routing/paths.ts
export const PATH_SERVICE_MAP: Array<[RegExp, string]> = [
  [/^\/db/, 'https://db.ACCOUNT.workers.dev'],
  [/^\/things/, 'https://db.ACCOUNT.workers.dev'],
  [/^\/auth/, 'https://auth.ACCOUNT.workers.dev'],
  [/^\/ai/, 'https://ai.ACCOUNT.workers.dev'],
  // ... 30+ path mappings
]
```

#### 1.2 Create Gateway Entry Point
```typescript
// @api/worker.ts (REPLACES current index.ts)
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { getDomainService, getPathService } from './routing'

const app = new Hono<{ Bindings: Env }>()

// Global middleware
app.use('*', cors())

// Pure routing - NO business logic
app.all('*', async (c) => {
  const url = new URL(c.req.url)

  // Try domain routing first
  const domainTarget = getDomainService(url.hostname)
  if (domainTarget) {
    return fetch(new Request(
      domainTarget + url.pathname + url.search,
      c.req.raw
    ))
  }

  // Try path routing
  const pathTarget = getPathService(url.pathname)
  if (pathTarget) {
    return fetch(new Request(
      pathTarget + url.pathname + url.search,
      c.req.raw
    ))
  }

  return c.json({ error: 'Not Found' }, 404)
})

export default app
```

#### 1.3 Update wrangler.jsonc
```jsonc
{
  "name": "api-gateway",
  "main": "worker.ts",
  "compatibility_date": "2024-10-01",
  "routes": [
    { "pattern": "api.services/*", "zone_name": "services" },
    { "pattern": "api.do/*", "zone_name": "do" }
  ],
  "observability": { "enabled": true }
}
```

### Phase 2: Middleware Layer (Days 2-3)

#### 2.1 Auth Middleware (HTTP-based)
```typescript
// @api/src/middleware/auth.ts
export const authMiddleware = ({ optional = false } = {}) => {
  return async (c: Context, next: Next) => {
    const token = c.req.header('Authorization')?.replace('Bearer ', '')

    if (!token && optional) {
      return await next()
    }

    if (!token) {
      return c.json({ error: 'Unauthorized' }, 401)
    }

    // Call auth service via HTTP (not RPC yet)
    const authResponse = await fetch('https://auth.ACCOUNT.workers.dev/validate', {
      headers: { 'Authorization': `Bearer ${token}` }
    })

    if (!authResponse.ok) {
      return c.json({ error: 'Invalid token' }, 401)
    }

    const user = await authResponse.json()
    c.set('user', user)
    await next()
  }
}
```

#### 2.2 Rate Limiting (Durable Objects)
```typescript
// @api/src/middleware/rate-limit.ts
export const rateLimitMiddleware = async (c: Context, next: Next) => {
  const RATE_LIMITER = c.env.RATE_LIMITER as DurableObjectNamespace

  const user = c.get('user')
  const key = user?.id || c.req.header('CF-Connecting-IP') || 'anonymous'

  const id = RATE_LIMITER.idFromName(key)
  const stub = RATE_LIMITER.get(id)

  const allowed = await stub.checkLimit()

  if (!allowed) {
    return c.json({ error: 'Rate limit exceeded' }, 429)
  }

  await next()
}
```

#### 2.3 Logging & Analytics
```typescript
// @api/src/middleware/logger.ts
export const loggerMiddleware = async (c: Context, next: Next) => {
  const start = Date.now()
  await next()
  const duration = Date.now() - start

  c.env.ANALYTICS.writeDataPoint({
    blobs: [c.req.method, c.req.path, c.res.status.toString()],
    doubles: [duration],
    indexes: [c.req.header('CF-Connecting-IP') || '']
  })
}
```

### Phase 3: Testing (Days 3-4)

#### 3.1 Unit Tests
```typescript
// @api/tests/routing.test.ts
describe('Gateway Routing', () => {
  it('should route domain to correct service', async () => {
    const req = new Request('https://db.mw/test')
    const res = await app.fetch(req, mockEnv)
    expect(res.ok).toBe(true)
  })

  it('should route path to correct service', async () => {
    const req = new Request('https://api.services/things/123')
    const res = await app.fetch(req, mockEnv)
    expect(res.ok).toBe(true)
  })
})
```

#### 3.2 Integration Tests
```typescript
// @api/tests/integration.test.ts
describe('End-to-End Routing', () => {
  it('should forward auth headers', async () => {
    const req = new Request('https://api.services/things', {
      headers: { 'Authorization': 'Bearer test-token' }
    })
    const res = await app.fetch(req, env)
    // Verify token was forwarded
  })
})
```

#### 3.3 Performance Tests
```typescript
// @api/tests/performance.test.ts
describe('Routing Performance', () => {
  it('should route in <1ms (p95)', async () => {
    const durations = []
    for (let i = 0; i < 1000; i++) {
      const start = Date.now()
      await app.fetch(new Request('https://db.mw/test'), env)
      durations.push(Date.now() - start)
    }
    const p95 = percentile(durations, 95)
    expect(p95).toBeLessThan(1)
  })
})
```

### Phase 4: Deployment (Days 4-5)

#### 4.1 Deploy to Staging
```bash
cd /Users/nathanclevenger/Projects/.do/api
wrangler deploy --env staging
```

#### 4.2 Configure Custom Domains
```bash
# Via Cloudflare Dashboard:
# - api.services ‚Üí api-gateway worker
# - api.do ‚Üí api-gateway worker
# - *.do ‚Üí api-gateway worker (wildcard)
```

#### 4.3 Monitor Performance
```bash
wrangler tail --env staging
```

#### 4.4 Deploy to Production
```bash
wrangler deploy --env production
```

---

## Service Bindings Strategy (Future Phase)

**After WS-002 is refactored as WorkerEntrypoint:**

### Update wrangler.jsonc
```jsonc
{
  "services": [
    { "binding": "DB", "service": "db" },
    { "binding": "AUTH", "service": "auth" },
    { "binding": "AI", "service": "ai" },
    // ... 30+ more
  ]
}
```

### Update Gateway Code
```typescript
// Replace HTTP fetch with RPC calls
const db = c.env.DB as DatabaseService
const result = await db.get(id)

const auth = c.env.AUTH as AuthService
const user = await auth.validateToken(token)
```

**Benefits of upgrade:**
- Faster (no HTTP overhead)
- Type-safe RPC calls
- Better error handling
- Easier testing

---

## Domain & Path Routing Tables

### Domain Routes (30+ domains)
```typescript
export const DOMAIN_ROUTES: Record<string, string> = {
  // Database
  'db.mw': 'db',
  'db.apis.do': 'db',

  // Agents
  'agents.do': 'agents',
  'agents.api.services': 'agents',

  // Workflows
  'workflows.do': 'workflows',
  'workflows.api.services': 'workflows',

  // Functions
  'functions.do': 'functions',
  'fn.do': 'functions',

  // MCP
  'mcp.do': 'mcp',
  'mcp.api.services': 'mcp',

  // AI
  'ai.do': 'ai',
  'generate.do': 'ai',

  // Auth
  'auth.do': 'auth',
  'login.do': 'auth',

  // Code
  'code.do': 'code-exec',
  'exec.do': 'code-exec',

  // Containers
  'containers.do': 'containers',
  'run.do': 'containers',

  // Sandboxes
  'sandbox.do': 'sandboxes',
  'sandboxes.do': 'sandboxes',

  // Docs
  'docs.do': 'docs',
  'documentation.do': 'docs',

  // Markdown
  'markdown.do': 'markdown',
  'md.do': 'markdown',

  // Utils
  'utils.do': 'utils',
  'util.do': 'utils',

  // Search
  'search.do': 'search',
  'find.do': 'search',

  // Marketplace
  'marketplace.do': 'marketplace',
  'store.do': 'marketplace',

  // Voice
  'voice.do': 'vapi',
  'vapi.do': 'vapi',

  // Payments
  'payments.do': 'stripe',
  'billing.do': 'stripe',

  // GitHub
  'github.do': 'github',
  'git.do': 'github',

  // Slack
  'slack.do': 'slack',

  // Main API
  'api.do': 'api-gateway',
  'api.services': 'api-gateway',
}
```

### Path Routes (30+ paths)
```typescript
export const PATH_ROUTES: Array<[RegExp, string]> = [
  // Database
  [/^\/db/, 'db'],
  [/^\/things/, 'db'],
  [/^\/relationships/, 'db'],

  // Auth
  [/^\/auth/, 'auth'],
  [/^\/login/, 'auth'],
  [/^\/logout/, 'auth'],

  // AI
  [/^\/ai/, 'ai'],
  [/^\/generate/, 'ai'],
  [/^\/embeddings/, 'embeddings'],

  // Search
  [/^\/search/, 'search'],

  // Code execution
  [/^\/execute/, 'code-exec'],
  [/^\/run/, 'code-exec'],

  // MCP
  [/^\/mcp/, 'mcp'],

  // Agents
  [/^\/agents/, 'agents'],

  // Workflows
  [/^\/workflows/, 'workflows'],

  // Functions
  [/^\/functions/, 'functions'],

  // Queue
  [/^\/queue/, 'queue'],

  // Events
  [/^\/events/, 'events'],

  // Batch
  [/^\/batch/, 'batch'],

  // Integrations
  [/^\/vapi/, 'vapi'],
  [/^\/stripe/, 'stripe'],
  [/^\/github/, 'github'],
  [/^\/slack/, 'slack'],
  [/^\/webhooks/, 'webhooks'],

  // Docs
  [/^\/docs/, 'docs'],
  [/^\/markdown/, 'markdown'],

  // Containers
  [/^\/containers/, 'containers'],

  // Sandboxes
  [/^\/sandboxes/, 'sandboxes'],

  // Utils
  [/^\/utils/, 'utils'],
]
```

---

## Success Criteria

### ‚úÖ Must Have (MVP)
- [ ] Domain routing working for 10+ domains
- [ ] Path routing working for 10+ paths
- [ ] HTTP forwarding to existing workers
- [ ] CORS configured
- [ ] Basic logging & analytics
- [ ] Deployed to staging
- [ ] Health check endpoint

### üéØ Should Have (Full)
- [ ] Auth middleware (HTTP-based)
- [ ] Rate limiting (Durable Objects)
- [ ] 30+ domain routes
- [ ] 30+ path routes
- [ ] Error handling
- [ ] Performance monitoring
- [ ] Integration tests

### üöÄ Nice to Have (Future)
- [ ] RPC service bindings (after WS-002 refactor)
- [ ] Request caching
- [ ] Load balancing
- [ ] Circuit breakers
- [ ] A/B testing support

---

## Performance Requirements

- **Routing Overhead:** <1ms (p95)
- **HTTP Forward:** <10ms (p95) - includes network
- **Auth Middleware:** <50ms (p95) - HTTP to auth service
- **Rate Limit Check:** <5ms (p95) - DO call
- **Total Latency:** <100ms (p95) - end-to-end

**Note:** RPC upgrade will reduce total latency to <20ms (p95)

---

## Anti-Patterns to AVOID

‚ùå NO business logic in gateway
‚ùå NO database queries (forward to @db/)
‚ùå NO authentication logic (forward to @auth/)
‚ùå NO data transformation (services do this)
‚ùå NO caching logic (services handle this)
‚ùå NO AI operations (services do this)

**The gateway is a PURE ROUTER** - it only routes requests to the appropriate service.

---

## Timeline

### Days 1-2: Core Routing
- ‚úÖ Create routing configuration
- ‚úÖ Implement gateway entry point
- ‚úÖ HTTP forwarding logic
- ‚úÖ Basic tests

### Days 2-3: Middleware
- ‚úÖ Auth middleware (HTTP)
- ‚úÖ Rate limiting (DO)
- ‚úÖ Logging & analytics
- ‚úÖ CORS

### Days 3-4: Testing
- ‚úÖ Unit tests
- ‚úÖ Integration tests
- ‚úÖ Performance tests

### Days 4-5: Deployment
- ‚úÖ Deploy to staging
- ‚úÖ Configure domains
- ‚úÖ Monitor metrics
- ‚úÖ Deploy to production

**Total Estimate:** 4-5 days

---

## Next Steps

1. **Immediate:** Start implementing Phase 1 (routing core)
2. **Day 2:** Add middleware layer
3. **Day 3-4:** Write tests
4. **Day 4-5:** Deploy and monitor

**Ready to begin implementation!**

---

## Notes

- Current @db/ worker uses ClickHouse (not PostgreSQL as originally planned)
- @auth/ is OAuth-based HTTP service (not RPC yet)
- Pragmatic approach: Start with HTTP forwarding, upgrade to RPC later
- Most workers already deployed and accessible via HTTP
- Gateway can be upgraded incrementally as services adopt RPC pattern

**Status:** APPROVED TO PROCEED with pragmatic HTTP-based approach
